预处理器把源代码中的宏去掉/替换 -> 由编译器将源代码翻译为汇编程序 -> 由汇编器将汇编程序翻译为目标文件 -> 链接器则将多个目标文件合为一个可执行文件

- [x86_64](#x86_64)
    - [寄存器](#寄存器)
    - [虚拟内存](#虚拟内存)
    - [栈](#栈)
    - [PC寄存器](#pc寄存器)
- [指令](#指令)
    - [操作数](#操作数)
    - [操作码](#操作码)
- [实战](#实战)

# X86_64
## 寄存器
16个64位的寄存器(而构成的寄存器文件)
![reg](./images/reg.jpg)
**16个寄存器，为什么有64个名称?**  
因为我们遇到的变量不一定都是64位的。以%rax为例，比如我要存储一个char类型的变量，那么我用得到的只有它的低8位，所以专门为这8位取名为%al（l代表low）；同理，如果要存储short类型的变量，则要用到它的低16位，专以%ax名之；若变量是int类型的，则要用到低32位，以%eax命名。  
这16个寄存器中，有的要承担特殊的任务，如果%rsp用于指向栈顶，%rax(及%eax等)要存储函数返回的值，有6个寄存器要用来保存函数的参数值，而有的则没有限制。其它寄存器还有caller-saved（调用者保存）, callee-saved（被调用者保存）的特性，这些在下文都会有详细的解释。  
![reg2](./images/reg2.jpg)
## 虚拟内存
不管是二进制代码本身还是部分临时变量都存储在内存中(还有部分存储在寄存器文件中)，它们时刻准备着为CPU所用(访问或写入)。
## 栈
它储存着临时变量，担任过程调用的中转站即保存返回地址，（可能过多的）参数，为当前过程储存临时变量。  
栈最重要的特征是有一个栈顶指针，这就是%rsp(16个寄存器之一)。我们知道，栈能操作的数据只有存储在栈顶的数据，所以几乎所有与栈相关的指令都离不开这根指针。栈有两个操作：压栈(push)和弹出（pop）。实际上，压栈是指，将栈顶指针往下移动若干个字节，使得栈的容量增大，再把新的数据填入栈顶。**为什么要往下移动呢？因为栈是向下“生长”的，也就是说，新进来的数据的地址小于旧的数据，而弹出是指，将栈顶指针上移若干字节。不必改变原来栈顶的值，因为随着栈顶指针的上移，原来的栈顶已经被排除在栈的范围之外。**
![stack](./images/stack.jpg)
在过程调用中，栈被分为多个部分，每一部分专门为一个过程服务，被称为“栈帧”。
```
栈帧（stack frame）是一种在程序执行过程中用于存储每一个函数调用的数据结构。它是运行时内存中的一部分，存储了函数的参数、返回地址、临时变量和其他执行环境相关的信息。
在计算机程序的执行过程中，当一个函数被调用时，系统会为这个函数分配一个新的栈帧，并将其压入栈顶，当函数执行结束并返回时，该栈帧就会从栈顶弹出
```
## PC寄存器
在汇编语言中以%rip表示，是非常关键的寄存器，它是CPU执行指令时的“指挥棒”。因为指令序列都保存在内存中，所以每一条指令都有相应的（虚拟）地址
![PCreg](./images/pcreg.jpg)  
**PC寄存器就存储着正在执行的指令的下一条要执行的指令**，PC寄存器并不会显式地出现在汇编代码中，其值的变化都是暗地里进行的。

## Flag寄存器（eflag: x86 32位）
条件码（Flag）是一种特殊的寄存器，它用于记录最近一次进行算术或逻辑指令后的状态，比如运算结果是否为零，是否溢出等信息。这些信息可以在后面的指令中使用，以决定后续的控制转移。例如，如果条件码记录着一个数值为零，那么在下一条指令中，就可以根据这个信息执行不同的操作。

# 指令
汇编代码一个指令可以完成一个CPU操作。一条指令由操作码和0～2个操作数构成。操作码指定了当前指令要执行的操作，如将两数相加，操作数则是操作码的作用对象。因此可以看出，**指令的长度不固定，短则1个字节，长则15字节。**
## 操作数
操作数可以是立即数、寄存器、内存地址。  
举例来说，$5是立即数，它的值5；%rax是寄存器，它的值是寄存器%rax中的值；0xf7是内存地址，它的值是内存中地址为0x07的某种类型的值；(%rax)也是内存的地址，只不过，该地址保留在寄存器%rax中；0xf7(%rax, %rbp, 4)也是内存的地址，所有的内存寻址方式都可以写成这种类型。
## 操作码
操作码分为算术逻辑类、数据传输类、控制类等等。
### 算术逻辑类
```
addq $3, %rdi
```
add代表相加，第一个操作数是源操作数，第二个是目的操作数。这个指令把立即数3加到寄存器%rdi中。如果之前%rdi中存储的值是8，则执行该指令之后变为11。

**add的后缀q代表着操作数的大小。有4种后缀：**  
b-字节(byte，8比特)  
w-字(word，16比特)  
l-双字(doubleword，32比特)  
q-四字(quadword, 64比特)  
![两个操作数](./images/caozuo1.jpg)
![一个操作数](./images/caozuo2.jpg)
### 数据传输类
```
movb $bl, %al
表示把%bl寄存器中的值赋值给%al

pushq %rbp
表示将%rbp的值压入栈中：即先使栈顶指针寄存器%rsp的值减少8，再将%rbp的值赋值给%rsp所指的内存单元。(回忆前面讲的压栈)

popq %rsi
表示将栈顶的8个字节的值弹出，并赋给寄存器%rsi。
```
### 控制类
jnz...
### 比较和测试操作码
```
cmpb %al, %bl
testq %rax, %rbx
```

# 实战
















